
###########################################################################################################################
#


### Ashley Sanders & David Porubsky
### May 20, 2015

################  ################	################	################  ################	################	################	################
################  this function will locate the breakpoints from deltaWs file                       ################
################  it will generate a file with predicted breakpoint start and ends for deltaWs above a threshold    ################
################  It outputs a breakpoint file that can be formatted for viewing on UCSC genome browser                                  ################
################  ################	################	################  ################	################	################	################


# deltaWs is a dataframe, contain startPos, endPos, deltaW
# trim will trim the upper and lower deltaWs in the dataset (e.g. 10 calculates SD of all values btwn 10th and 90th percentile)
# peakTh determines the fraction of the upper peak to use as the threshold (th) (e.g. 0.33 is 1/3 of max(delta))
# zlim is the degree that the value must be above the th to be included in the peaklist
# zscore = 1.96 > 95% confidence; 2.576 > 99%; 3.291 > 99.9% confidence


## to call:
#breaks<- breakSeekR(deltaWs)

breakSeekR<- function(deltaWs, trim=10, peakTh=0.33, zlim=3.291) 
{
 
  th<- max(deltaWs$deltaW)*peakTh # calculates the fraction (e.g. 0.33) of the highest deltaW > this will be the th
  
  ## #group the breakpoints to refine at the peak of the peak:
 
  if (mean(deltaWs$deltaW) > 1){ # if mean is so low than there is no peak, skip library
    trimVs<- deltaWs[quantile(deltaWs$deltaW, (trim/100) ) < deltaWs$deltaW & deltaWs$deltaW < quantile(deltaWs$deltaW, ((100-trim)/100) ),3]  # trims the outer 5% limit of the deltaWs to calulate the stdev
    if(length(trimVs) <= 1){trimVs <- c(0,0,0)} #'*'#
    
    # calculate zscores, which determine if deltaW is significantly ABOVE the sd
    if (sd(trimVs) == 0){ 
      zscores <- (deltaWs$deltaW - th) / sd(deltaWs$deltaW) 
    }else{
      zscores <- (deltaWs$deltaW - th) / sd(trimVs)
    }  
    
    peakList<- data.frame(startPos=vector(), endPos=vector(), deltaW=vector(), group=vector())
    group <- 1
    line<-1
  
    for (z in zscores) {
      line<- line+1
      if (z > zlim) {  # consides the line only if deltaW is signficantly above the th 
        peak <- cbind(deltaWs[line,], group)  # appends a group No. to the line
        peakList<- rbind(peakList, peak) # includes in the peaklist a group # to the line
      } else {  group<- group+1 # if the deltaW passes below the th, increase group No.
      }}
      peakList<- na.omit(peakList)
      ## the peakList contains all the peaks above the th, grouped together if they pass consecutively   
  
      ### refine breakpoints of the grouped peaks in the peakList

      if (nrow(peakList) > 0){ # if there are peaks present, find the breakpoints (else peakList not mapped)
        breaks<- data.frame(fiveP=vector(), threeP=vector(), max_dW=vector(), reads=vector())
        for (g in unique(peakList$group)) {
          peak <-peakList[which(peakList[,4] == g),]
          if (nrow(peak) > 1){ # ensures peak has more than 1 window above the threshold
          breakp<- data.frame(fiveP=min(peak[which(peak$deltaW == max(peak$deltaW)),1]), threeP=max(peak[which(peak$deltaW == max(peak$deltaW)),2]), max_dW=max(peak$deltaW), windows=nrow(peak))
          breaks<- rbind(breaks, breakp)
      }}
      return(breaks)
      } else{ message('no peaks here!')}
    
      # simple plot, if desired
      # plot(deltaWs[,1], deltaWs[,3], type="l")
      # lines(peakList[,1], peakList[,3], col='red')
    
  } else{ message('no peaks here!')}
}
    
